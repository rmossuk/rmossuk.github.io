{"name":"EmberData - What happens when you commit ?","tagline":"Deep dive into the EmberData commit process","body":"I have been using Ember.js and EmberData for a long time now and most of my battles still seem to be in EmberData. Therefore i have decided to dive into EmberData and see exactly how the magic works and hopefully why the problems are happening, so that one day i may be able to help fix them !\r\n\r\nI am going to start with detailing the process of what actually happens when commit is called.\r\n\r\n### The test code\r\n\r\nI have this simple one-to-many relationship. ( Coffeescript )\r\n\r\n```\r\nApp.Product = DS.Model.extend \r\n  name: DS.attr('string')\r\n  children: DS.hasMany('App.BuildingBlocks')\r\n\r\nApp.BuildingBlock = DS.Model.extend \r\n  name: DS.attr('string')\r\n  parent: DS.belongsTo('App.Product')\r\n```\r\n\r\nI have created and committed a product prior to this so now have access to App.product and now i want to add a building block to this product, so i have done\r\n\r\n```\r\nnewBuildingBlock = App.product.get(\"children\").createRecord()\r\nnewBuildingBlock.set(\"parent\", App.product)\r\nApp.store.commit()\r\n```\r\n\r\nThis magically saves this of to my server but what actually happens ?\r\n\r\nLets follow it through the process.\r\n\r\n### DS.Store\r\nWithin DS.Store the commit method just delegates to the stores defaultTransaction's commit method.\r\n\r\nWith EmberData you can create multiple transactions and add specific creates, changes and deletes to any transaction.  Doing this allows you to group related changes together and commit just those changes or roll back the changes.\r\n\r\nIf you do not create a DS.Transaction and add changes to it, EmberData with use the 'defaultTransaction' and add all changes to this global transaction.  This means that when you commit, all changes with be saved.\r\n\r\n### DS.Transaction\r\n\r\nWhen the defaultTransaction is initialised it creates some buckets (clean, created, updated, deleted and inflight) in the form of Ember.OrderedSet's.\r\n\r\n```\r\nset(this, 'buckets', {\r\n  clean:    Ember.OrderedSet.create(),\r\n  created:  Ember.OrderedSet.create(),\r\n  updated:  Ember.OrderedSet.create(),\r\n  deleted:  Ember.OrderedSet.create(),\r\n  inflight: Ember.OrderedSet.create()\r\n});\r\n```\r\n\r\nWhenever a record is changed it is added to the relavent bucket to be used when commit is called on the transaction.  For example when we created a new App.BuildingBlock record, this object was added to the created bucket.\r\n\r\nWithin DS.Transaction#commit we get the store, the stores adapter and the stores defaultTransaction to use.  Then we get the stores 'relationships'. ????WHAT ARE RELATIONSHIPS ????\r\n\r\nThen a commitDetails object with created, updated, deleted and relationships properties is created.  Each of these references the relavent bucket on this transaction.\r\n\r\nFor each record in the created, updated, deleted buckets, it's send method is called with 'willCommit'.   \r\n\r\nWe only have a record in the created bucket.\r\n\r\n### DS.Model\r\nWithin DS.Model the send method just delegates to the App.BuildingBlock instances statemanger#send method\r\n\r\n### DS.Statemanager\r\nWithin DS.Statemanager the send method receives the 'willCommit' event and checks that the event can be sent while in this current state (which is \"uncommited\" at the moment).   If it can't it will thow the dreaded 'Cannot send event while currentState is' error message!\r\n\r\nThe sendEvent function is called that then calls the sendRecursively function on the statemanager with event name and the currentState which is an instance of DS.State.\r\n\r\nthe sendRecursively function then transitions the statemanager's state to 'inflight'\r\n\r\n### Back to DS.Transaction\r\nIf this transaction is the defaultTransaction then a new transaction is created with this store.  Then the stores defaultTransaction is set to this new transaction.\r\n\r\nNext removeCleanRecords is called does what it says and removes all records from within the clean bucket.\r\n\r\nCheck if there are any records in the created, updated, deleted or relationships.  If so if there is an adapter and it has a commit method then adapter.commit is called with the store and the commitDetails object containing the buckets.  Error if no adapter or commit method.\r\n\r\n### DS.Adapter\r\nThe DS.Adapter#commit method just delegates to the save method\r\n\r\nDS.Adapter#save method creates an Ember.MapWithDefault for each of the created, updated and deleted buckets and loops each record.\r\n\r\nWe only have one in the created bucket.\r\n\r\nThe created bucket is passed through the filter method that loops each record in the bucket and adds it to a new Ember.OrderedSet if the adapter shouldSave method is true.\r\n\r\n### DS.RESTAdapter\r\nThe shouldSave method gets the records '_reference' and checks that it does not have a parent. Which ours does'nt and returns true.  \r\nThe '_reference' property on the record is a computed property that calls the store#referenceForClientId method with the records clientId.\r\n\r\n### DS.Store\r\nreferenceForClientId checks the recordReferences object for the clientId and returns this object if exists.  If not it gets the clientIdToType[clientId] object and adds this record to the recordReferences object and returns this object.\r\n\r\nThe recordReferences and clientIdToType objects are stated as internal bookkeeping will have to look into that later!\r\n\r\n### Back to DS.RESTAdapter\r\nThe createRecords method is called with the store, type ( App.BuildingBlock ) and the new Ember.OrderedSet with the created record in it.\r\n\r\nIn createRecords it checks if bulkCommit is set to false.  I have this set to false so we will continue on this path for now!\r\n\r\nThe adapters _super createRecords method is then called which is DS.Adapter.  \r\n\r\n### DS.Adapter\r\nThis method then loops each record in the bucket and calls DS.RESTAdapter createRecord\r\n\r\n### DS.RESTAdapter\r\nThe createRecord method calls the rootForType method with the type (App.BuildingBlock) that returns \"building_block\".  The rootForType method calls rootForType on its 'serializer'\r\n\r\nNOTE: get(this, 'serializer').toString() returns \"<DS.RESTSerializer:ember3759>\" and not \"<DS.JSONSerializer:ember3759>\". Is this a bug ?\r\n\r\n### DS.JSONSerializer\r\nthis rootForType method turns App.BuildingBlock into \"building_block\" string.\r\n\r\n### Back to DS.RESTAdapter createRecord method\r\ncalls serialize method with the recoed and  { includeId: true } object.\r\n\r\n### DS.Adapter\r\nserialize method just delegates to its serializer#serialize method.\r\n\r\n### DS.Serializer\r\nThe serialize method calls createSerializedForm that creates an empty hash for anyone to hook into.  This is saved as serialized var.\r\n\r\nIf the options has includedId which is default and the record has an id which it has not yet call '_addId' unless call addAttributes\r\n\r\naddAttributes loops the records eachAttributes and calls '_addAttribute' with the so far empty serialized hash, the record, the name of the attribute (ie name) and the attribute.type ( string in this case )\r\n\r\n_addAttribute calls _keyForAttributeName to get the key for the current attribute ( name )\r\n\r\n_keyForAttributeName calls _keyFromMappingOrHook with 'keyForAttributeName'\r\n\r\n_keyFromMappingOrHook checks for a mapping key for this attribute and if found returns this unless call the public hook method 'keyForAttributeName' where you can implement your own functionality\r\n\r\nback in the _addAttribute method call public addAttribute method with the still so far empty serialized hash, the key ( name ) and the result of serializedValue(value, type).  This performs any transforms that you have setup for this attribute type.  You can create your own custom transforms here.  Basically strings are just converted to String, number to Number etc just in case.\r\n\r\n### DS.JSONSerializer\r\naddAttribute method just adds this attribute name and value to the serialized hash.  You can hook into here to cusomize how you want to add the key/value to the serialized hash\r\n\r\n### back into DS.Serializer serialize method\r\ncall addRelationships\r\n\r\naddRelationships loops each relationship for this record and if its a 'hasMany' calls _addHasMany\r\n\r\n_addHasMany gets the key for the relationship via mappings or public custom hooks and calls addHasMany\r\n\r\n### DS.JSONSerializer\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}