{"name":"EmberData - What happens when you commit ?","tagline":"Deep dive into the EmberData commit process","body":"I have been using Ember.js and EmberData for a long time now and most of my battles still seem to be in EmberData. Therefore i have decided to dive into EmberData and see exactly how the magic works and hopefully why the problems are happening, so that one day i may be able to help fix them !\r\n\r\nI am going to start with detailing the process of what actually happens when commit is called.\r\n\r\n### The test code\r\n\r\nI have this simple one-to-many relationship. ( Coffeescript )\r\n\r\n```\r\nApp.Product = DS.Model.extend \r\n  name: DS.attr('string')\r\n  children: DS.hasMany('App.BuildingBlocks')\r\n\r\nApp.BuildingBlock = DS.Model.extend \r\n  name: DS.attr('string')\r\n  parent: DS.belongsTo('App.Product')\r\n```\r\n\r\nI have created and committed a product prior to this so now have access to App.product and now i want to add a building block to this product, so i have done\r\n\r\n```\r\nnewBuildingBlock = App.product.get(\"children\").createRecord()\r\nnewBuildingBlock.set(\"parent\", App.product)\r\nApp.store.commit()\r\n```\r\n\r\nThis magically saves this of to my server but what actually happens ?\r\n\r\nLets follow it through the process.\r\n\r\n### DS.Store\r\nWithin DS.Store the commit method just delegates to the stores defaultTransaction's commit method.\r\n\r\nWith EmberData you can create multiple transactions and add specific creates, changes and deletes to any transaction.  Doing this allows you to group related changes together and commit just those changes or roll back the changes.\r\n\r\nIf you do not create a DS.Transaction and add changes to it, EmberData with use the 'defaultTransaction' and add all changes to this global transaction.  This means that when you commit, all changes with be saved.\r\n\r\n### DS.Transaction\r\n\r\nWhen the defaultTransaction is initialised it creates some buckets (clean, created, updated, deleted and inflight) in the form of Ember.OrderedSet's.\r\n\r\n```\r\nset(this, 'buckets', {\r\n  clean:    Ember.OrderedSet.create(),\r\n  created:  Ember.OrderedSet.create(),\r\n  updated:  Ember.OrderedSet.create(),\r\n  deleted:  Ember.OrderedSet.create(),\r\n  inflight: Ember.OrderedSet.create()\r\n});\r\n```\r\n\r\nWhenever a record is changed it is added to the relavent bucket to be used when commit is called on the transaction.  For example when we created a new App.BuildingBlock record, this object was added to the created bucket.\r\n\r\nWithin DS.Transaction#commit we get the store, the stores adapter and the stores defaultTransaction to use.  Then we get the stores 'relationships'. ????WHAT ARE RELATIONSHIPS ????\r\n\r\nThen a commitDetails object with created, updated, deleted and relationships properties is created.  Each of these references the relavent bucket on this transaction.\r\n\r\nFor each record in the created, updated, deleted buckets, it's send method is called with 'willCommit'\r\n\r\n### DS.Model\r\nWithin DS.Model the send method just delegates to the App.BuildingBlock instances statemanger#send method\r\n\r\n### DS.Statemanager\r\nWithin DS.Statemanager the send method receives the 'willCommit' event and checks that the event can be sent while in this current state (which is \"uncommited\" at the moment).   If it can't it will thow the dreaded 'Cannot send event while currentState is' error message!\r\n\r\nThe sendEvent function is called that then calls the sendRecursively function with event name and the statemanager\r\n\r\n\t- then the sendRecursively function ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}